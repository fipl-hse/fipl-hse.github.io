<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Лабораторная работа №4. Векторный поиск на основе кластеризации &mdash; Программирование для лингвистов  documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../../_static/design-tabs.js?v=36754332"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
    <link rel="next" title="lab_4_retrieval_w_clustering package" href="lab_4_retrieval_w_clustering.api.html" />
    <link rel="prev" title="lab_3_ann_retriever package" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            Программирование для лингвистов
              <img src="../../../../_static/fal_logo.jpeg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../useful_docs/index.html">Полезные Материалы</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../labs_2023/index.html">Курс “Программирование для лингвистов” (2023/2024)</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Курс “Программирование для лингвистов” (2024/2025)</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../general_info.html">Общая информация</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">Лабораторные работы</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../lab_1_classify_by_unigrams/lab_1.html">Лабораторная работа №1. Определение языка текста на основе частотного словаря</a></li>
<li class="toctree-l3"><a class="reference internal" href="../lab_2_retrieval_w_bm25/lab_2.html">Лабораторная работа №2. Оценка релевантности документов с помощью BM25</a></li>
<li class="toctree-l3"><a class="reference internal" href="../lab_3_ann_retriever/lab_3.html">Лабораторная работа №3. Получение релевантных документов на основе векторного поиска</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Лабораторная работа №4. Векторный поиск на основе кластеризации</a><ul>
<li class="toctree-l4"><a class="reference internal" href="lab_4_retrieval_w_clustering.api.html">lab_4_retrieval_w_clustering package</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../lectures_content_ru.html">Краткий конспект лекций</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../useful_docs/general_docs/index.html">Полезные материалы для курсов на русском языке</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../labs_2025/index.html">Курс “Программирование для лингвистов” (2025/2026)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ctlr_2023/index.html">Technical Track of Computer Tools for Linguistic Research (2023/2024)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ctlr_2024/index.html">Technical Track of Computer Tools for Linguistic Research (2024/2025)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../llm_2023/index.html">Курс “Информационный поиск и извлечение данных” (2023/2024)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../llm_2024/index.html">Курс “Информационный поиск и извлечение данных” (2024/2025)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../llm_2025/index.html">Курс “Информационный поиск и извлечение данных” (2025/2026)</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Программирование для лингвистов</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Курс “Программирование для лингвистов” (2024/2025)</a></li>
          <li class="breadcrumb-item"><a href="../index.html">Лабораторные работы</a></li>
      <li class="breadcrumb-item active">Лабораторная работа №4. Векторный поиск на основе кластеризации</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../../_sources/docs/labs_2024/labs/lab_4_retrieval_w_clustering/lab_4.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="o4">
<h1>Лабораторная работа №4. Векторный поиск на основе кластеризации<a class="headerlink" href="#o4" title="Link to this heading"></a></h1>
<div class="toctree-wrapper compound">
<p class="caption" role="heading"><span class="caption-text">Full API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="lab_4_retrieval_w_clustering.api.html">lab_4_retrieval_w_clustering package</a></li>
</ul>
</div>
<section id="id1">
<h2>Дано<a class="headerlink" href="#id1" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>Хранящиеся в папке <code class="docutils literal notranslate"><span class="pre">assets/texts</span></code> 10 глав художественного произведения
«Мастер и Маргарита» и 10 глав первого тома романа «Война и Мир» на русском языке.</p></li>
<li><p>Список стоп-слов русского языка из библиотеки <code class="docutils literal notranslate"><span class="pre">NLTK</span></code>, хранящийся в файле
<code class="docutils literal notranslate"><span class="pre">assets/stopwords.txt</span></code>. Стоп-слова уже импортированы в файл <code class="docutils literal notranslate"><span class="pre">start.py</span></code>
в функции <code class="docutils literal notranslate"><span class="pre">open_files()</span></code> в переменную <code class="docutils literal notranslate"><span class="pre">stopwords</span></code> в виде списка.</p></li>
</ol>
<p>В предыдущих лабораторных работах Вы научились:</p>
<ul class="simple">
<li><p>обрабатывать входящие текстовые данные;</p></li>
<li><p>получать векторные представления текстов (эмбеддинги) на основе метрики BM25;</p></li>
<li><p>получать релевантные документы на основе различных метрик, таких как TF-IDF, BM25
и оптимизированной метрики BM25;</p></li>
<li><p>оптимизировать алгоритм векторного поиска с помощью метода KNN и структуры данных KDTree.</p></li>
</ul>
<p>В настоящей лабораторной работе Вам предстоит построить полноценную интеграционную систему
векторного поиска по абзацам, создав собственную базу текстовых данных и оптимизировав
векторный поиск с помощью алгоритма кластеризации K-Means.</p>
</section>
<section id="id2">
<h2>Что необходимо сделать<a class="headerlink" href="#id2" title="Link to this heading"></a></h2>
<section id="id3">
<h3>Шаг 0. Начать работу над лабораторной<a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p>Измените файлы <code class="docutils literal notranslate"><span class="pre">main.py</span></code> и <code class="docutils literal notranslate"><span class="pre">start.py</span></code>.</p></li>
<li><p>Закоммитьте изменения и создайте новый Pull Request.</p></li>
</ol>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Код, выполняющий все требуемые действия, должен быть написан в
функции <code class="docutils literal notranslate"><span class="pre">main</span></code> в модуле <code class="docutils literal notranslate"><span class="pre">start.py</span></code>.</p>
</div>
<p>Для этого реализуйте функции в модуле <code class="docutils literal notranslate"><span class="pre">main.py</span></code> и импортируйте их в
<code class="docutils literal notranslate"><span class="pre">start.py</span></code>. Весь код, выполняющий лабораторную работу, должен быть
выполнен в функции <code class="docutils literal notranslate"><span class="pre">main</span></code> в файле <code class="docutils literal notranslate"><span class="pre">start.py</span></code>:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>В рамках данной лабораторной работы <strong>нельзя использовать модули
collections, itertools, а также сторонние модули.</strong></p>
<p>Обратите внимание, что желаемую оценку необходимо указать в файле
<code class="docutils literal notranslate"><span class="pre">settings.json</span></code> в поле <code class="docutils literal notranslate"><span class="pre">target_score</span></code>. Возможные значения: 0, 4, 6, 8, 10.
Чем выше желаемая оценка, тем больше
тестов запустится при проверке Вашего Pull Request.</p>
</section>
<section id="id4">
<h3>Шаг 1. Творческое задание (будет анонсировано преподавателем на лекции)<a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Выполнение Шага 1 соответствует 4 баллам.</p>
</div>
</section>
<section id="id5">
<h3>Шаг 2. Получить абзацы текста<a class="headerlink" href="#id5" title="Link to this heading"></a></h3>
<p>На протяжении данной лабораторной Вы будете работать с более мелкими единицами, чем текст,
а именно с абзацами. Хранение данных в таком виде позволяет находить более релевантную
информацию под имеющийся запрос.</p>
<p>Для того чтобы получить список абзацев текста, реализуйте функцию
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.get_paragraphs" title="lab_4_retrieval_w_clustering.main.get_paragraphs"><code class="xref py py-func docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.get_paragraphs()</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Критерием нового абзаца является символ переноса строки.</p>
</div>
<p>Например, пусть функция принимает на вход следующий текст:</p>
<p><code class="docutils literal notranslate"><span class="pre">'Привет!</span> <span class="pre">Как</span> <span class="pre">твои</span> <span class="pre">дела?\nХорошо.</span> <span class="pre">Как</span> <span class="pre">твои</span> <span class="pre">дела?\nУ</span> <span class="pre">меня</span> <span class="pre">всё</span> <span class="pre">отлично\nКак</span>
<span class="pre">ты</span> <span class="pre">смотришь</span> <span class="pre">на</span> <span class="pre">то,</span> <span class="pre">чтобы</span> <span class="pre">сходить</span> <span class="pre">попить</span> <span class="pre">кофе?'</span></code>.</p>
<p>Тогда функция вернет нам следующий список строк, являющихся абзацами:</p>
<p><code class="docutils literal notranslate"><span class="pre">['Привет!</span> <span class="pre">Как</span> <span class="pre">твои</span> <span class="pre">дела?',</span> <span class="pre">'Хорошо.</span> <span class="pre">Как</span> <span class="pre">твои</span> <span class="pre">дела?',</span>
<span class="pre">'У</span> <span class="pre">меня</span> <span class="pre">всё</span> <span class="pre">отлично',</span> <span class="pre">'Как</span> <span class="pre">ты</span> <span class="pre">смотришь</span> <span class="pre">на</span> <span class="pre">то,</span> <span class="pre">чтобы</span> <span class="pre">сходить</span> <span class="pre">попить</span> <span class="pre">кофе?']</span></code></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Если на вход в функцию подаётся пустой аргумент,
то необходимо вызвать исключение <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
</div>
</section>
<section id="bm25">
<h3>Шаг 3. Объявить сущность для векторизации текстов с помощью метрики BM25<a class="headerlink" href="#bm25" title="Link to this heading"></a></h3>
<p>Формальные модели, включая лингвистические модели, не способны обрабатывать
буквенные данные, поэтому необходимо для каждой текстовой последовательности
сформировать числовой вектор.</p>
<p>В лабораторой работе №3 Вы уже познакомились с понятием векторного представления
текстов. В данном случае нам так же необходимо получить векторы абзацев. Для
этого реализуйте класс <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.BM25Vectorizer" title="lab_4_retrieval_w_clustering.main.BM25Vectorizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.BM25Vectorizer</span></code></a>.
Данный класс является наследником класса <a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.Vectorizer" title="lab_3_ann_retriever.main.Vectorizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.Vectorizer</span></code></a>,
который уже был реализован Вами в предыдущей лабораторной. Отличие данного класса
лишь в том, что векторизация происходит не на основе метрики TF-IDF, а на
основе алгоритма BM25.</p>
<p>Класс имеет следующие атрибуты:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self._corpus</span></code> - список токенизированных абзацев, за вид которых в данной работе
отвечает тип <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.TokenizedCorpus" title="lab_4_retrieval_w_clustering.main.TokenizedCorpus"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.TokenizedCorpus</span></code></a>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self._avg_doc_len</span></code> - средняя длина абзацев в корпусе.</p></li>
</ul>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Оба эти атрибута являются защищенными, то есть обращение
к ним за пределами методов этого класса не предполагается.</p>
</div>
<p>При инициализации данного класса заполните атрибуты дефолтными значениями.
Например, пусть <code class="docutils literal notranslate"><span class="pre">self._corpus</span> <span class="pre">=</span> <span class="pre">[]</span></code> и <code class="docutils literal notranslate"><span class="pre">self._avg_doc_len</span> <span class="pre">=</span> <span class="pre">-1.0</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Не забудьте при инициализации класса наследника вызвать
конструктор класса родителя, чтобы иметь возможность переиспользовать
все его атрибуты и методы.</p>
</div>
<p>Пример создания экземпляра класса:</p>
<blockquote>
<div><div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">vectorizer</span> <span class="o">=</span> <span class="n">BM25Vectorizer</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="bm25vectorizer">
<h3>Шаг 3.1. Заполнить атрибуты класса BM25Vectorizer<a class="headerlink" href="#bm25vectorizer" title="Link to this heading"></a></h3>
<p>Реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.BM25Vectorizer.set_tokenized_corpus" title="lab_4_retrieval_w_clustering.main.BM25Vectorizer.set_tokenized_corpus"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.BM25Vectorizer.set_tokenized_corpus()</span></code></a>,
который принимает на вход список токенизированных абзацев и заполняет им атрибут
<code class="docutils literal notranslate"><span class="pre">self._corpus</span></code>. Используя полученный корпус, заполните атрибут <code class="docutils literal notranslate"><span class="pre">self._avg_doc_len</span></code>
корректным значением.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Если на вход подаётся пустой аргумент,
то необходимо вызвать исключение <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
</div>
</section>
<section id="id6">
<h3>Шаг 3.2. Посчитать BM25 для абзаца<a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<p>Реализуйте метод <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.BM25Vectorizer._calculate_bm25" title="lab_4_retrieval_w_clustering.main.BM25Vectorizer._calculate_bm25"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.BM25Vectorizer._calculate_bm25()</span></code></a>,
который вычисляет <code class="docutils literal notranslate"><span class="pre">BM25</span></code> и создаёт вектор документа.
Для того чтобы сразу учесть неизменяемость размерности вектора, создайте
вектор из нулей длины списка <code class="docutils literal notranslate"><span class="pre">self._vocabulary</span></code>, атрибута из класса родителя.
Затем заполните созданный вектор значениями <code class="docutils literal notranslate"><span class="pre">BM25</span></code>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Для вычисления метрики <code class="docutils literal notranslate"><span class="pre">BM25</span></code> используйте функцию
<a class="reference internal" href="../lab_2_retrieval_w_bm25/lab_2_retrieval_w_bm25.api.html#lab_2_retrieval_w_bm25.main.calculate_bm25" title="lab_2_retrieval_w_bm25.main.calculate_bm25"><code class="xref py py-func docutils literal notranslate"><span class="pre">lab_2_retrieval_w_bm25.main.calculate_bm25()</span></code></a>.</p>
</div>
<p>Например, вектор уже знакомого нам абзаца
<code class="docutils literal notranslate"><span class="pre">'Привет!</span> <span class="pre">Как</span> <span class="pre">твои</span> <span class="pre">дела?'</span></code> будет выглядеть так:
<code class="docutils literal notranslate"><span class="pre">(0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.8139979444767895,</span> <span class="pre">0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0)</span></code>.</p>
</section>
<section id="id7">
<h3>Шаг 3.3. Векторизировать документ<a class="headerlink" href="#id7" title="Link to this heading"></a></h3>
<p>Переопределите поведение метода <a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.Vectorizer.vectorize" title="lab_3_ann_retriever.main.Vectorizer.vectorize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.Vectorizer.vectorize()</span></code></a>
в классе наследнике <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.BM25Vectorizer" title="lab_4_retrieval_w_clustering.main.BM25Vectorizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.BM25Vectorizer</span></code></a>,
который возвращает векторное представление абзаца.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Метод должен вызывать защищённый метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.BM25Vectorizer._calculate_bm25" title="lab_4_retrieval_w_clustering.main.BM25Vectorizer._calculate_bm25"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.BM25Vectorizer._calculate_bm25()</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Если на вход подаётся пустой аргумент или вызываемые методы возвращают значение <code class="docutils literal notranslate"><span class="pre">None</span></code>,
то необходимо поднять исключение <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
</div>
<p>Вызов данного метода может выглядеть следующим образом:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">tokenized_paragraphs</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;привет&#39;</span><span class="p">,</span> <span class="s1">&#39;твои&#39;</span><span class="p">,</span> <span class="s1">&#39;дела&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;твои&#39;</span><span class="p">,</span> <span class="s1">&#39;дела&#39;</span><span class="p">]]</span>
<span class="n">vectorizer</span> <span class="o">=</span> <span class="n">BM25Vectorizer</span><span class="p">()</span>
<span class="n">vectorizer</span><span class="o">.</span><span class="n">set_tokenized_corpus</span><span class="p">(</span><span class="n">tokenized_paragraphs</span><span class="p">)</span>
<span class="n">vectorizer</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
<span class="n">vectorizer</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">tokenized_paragraphs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="id8">
<h3>Шаг 4. Объявить сущность для создании векторной базы данных<a class="headerlink" href="#id8" title="Link to this heading"></a></h3>
<p>В предыдущей лабораторной работе для того чтобы получить ответ на некоторый запрос,
необходимо было проиндексировать хранящиеся для сравнения документы, каждый раз
вызывая при добавлении нового документа метод
<a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.BasicSearchEngine.index_documents" title="lab_3_ann_retriever.main.BasicSearchEngine.index_documents"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.BasicSearchEngine.index_documents()</span></code></a>.</p>
<p>В больших поисковых системах данные не обрабатываются и не векторизируются
при каждом запросе заново. Вместо этого они предварительно
индексируются и хранятся в специализированных базах данных, чтобы обеспечить
быструю и эффективную обработку запросов пользователей. Кроме того,
создание таких баз данных позволяет хранить документы и их векторы в одном месте.</p>
<p>В данной лабораторной работе Вы создаете прототип поисковой системы. Следовательно,
необходимо создать базу данных, которая будет хранить документы и их векторы.
Для этого реализуйте класс <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB</span></code></a>.
необходимо создать базу данных.</p>
<p>Класс имеет следующие атрибуты:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self._tokenizer</span></code> - объект класса <a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.Tokenizer" title="lab_3_ann_retriever.main.Tokenizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.Tokenizer</span></code></a>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self._vectorizer</span></code> - объект класса <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.BM25Vectorizer" title="lab_4_retrieval_w_clustering.main.BM25Vectorizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.BM25Vectorizer</span></code></a>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self.__documents</span></code> - список абзацев, за вид которых в данной работе
отвечает тип <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.Corpus" title="lab_4_retrieval_w_clustering.main.Corpus"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.Corpus</span></code></a>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self.__vectors</span></code> - словарь, который хранит в себе уникальный индекс абзаца в качестве ключа и
вектор данного абзаца (за вид вектора абзаца отвечает тип
<a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.Vector" title="lab_3_ann_retriever.main.Vector"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.Vector</span></code></a>).</p></li>
</ul>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Атрибуты <code class="docutils literal notranslate"><span class="pre">self._tokenizer</span></code> и <code class="docutils literal notranslate"><span class="pre">self._vectorizer</span></code> являются защищёнными, а
атрибуты <code class="docutils literal notranslate"><span class="pre">self.__documents</span></code> и <code class="docutils literal notranslate"><span class="pre">self.__vectors</span></code> - приватными. Подумайте,
почему так сделано, и поделитесь ответом с ментором во время защиты лабораторной работы.</p>
</div>
<p>Пример создания экземпляра класса:</p>
<blockquote>
<div><div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">stop_words</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;и&#39;</span><span class="p">,</span> <span class="s1">&#39;в&#39;</span><span class="p">,</span> <span class="s1">&#39;во&#39;</span><span class="p">,</span> <span class="s1">&#39;не&#39;</span><span class="p">]</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">DocumentVectorDB</span><span class="p">(</span><span class="n">stop_words</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="id9">
<h3>Шаг 4.1. Заполнить базу данных абзацами и их векторными представлениями<a class="headerlink" href="#id9" title="Link to this heading"></a></h3>
<p>Реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.put_corpus" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.put_corpus"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.put_corpus()</span></code></a>,
который принимает на вход список абзацев и заполняет атрибуты
<code class="docutils literal notranslate"><span class="pre">self.__documents</span></code> и <code class="docutils literal notranslate"><span class="pre">self.__vectors</span></code>.</p>
<p>Для заполнения атрибута <code class="docutils literal notranslate"><span class="pre">self.__vectors</span></code> Вам потребуется использовать
метод <a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.Tokenizer.tokenize" title="lab_3_ann_retriever.main.Tokenizer.tokenize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.Tokenizer.tokenize()</span></code></a>, а также метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.BM25Vectorizer.vectorize" title="lab_4_retrieval_w_clustering.main.BM25Vectorizer.vectorize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.BM25Vectorizer.vectorize()</span></code></a>, предварительно
заполнив атрибуты <code class="docutils literal notranslate"><span class="pre">self._corpus</span></code>, <code class="docutils literal notranslate"><span class="pre">self._avg_doc_len</span></code> и <code class="docutils literal notranslate"><span class="pre">self._vocabulary</span></code>,
используя объект класса <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.BM25Vectorizer" title="lab_4_retrieval_w_clustering.main.BM25Vectorizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.BM25Vectorizer</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Обратите внимание, что если документ состоит полностью из стоп-слов, то после токенизации
возвращается пустой список. В данном случае необходимо пропускать такие значения и не добавлять
в корпус токенизированных документов.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Если на вход подаётся пустой аргумент или вызываемые методы возвращают значение <code class="docutils literal notranslate"><span class="pre">None</span></code>,
то необходимо поднять исключение <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
</div>
</section>
<section id="id10">
<h3>Шаг 4.2. Получить векторизатор<a class="headerlink" href="#id10" title="Link to this heading"></a></h3>
<p>Реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectorizer" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectorizer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectorizer()</span></code></a>,
который возвращает объект класса <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.BM25Vectorizer" title="lab_4_retrieval_w_clustering.main.BM25Vectorizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.BM25Vectorizer</span></code></a>.</p>
</section>
<section id="id11">
<h3>Шаг 4.3. Получить токенизатор<a class="headerlink" href="#id11" title="Link to this heading"></a></h3>
<p>Реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_tokenizer" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_tokenizer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_tokenizer()</span></code></a>,
который возвращает объект класса <a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.Tokenizer" title="lab_3_ann_retriever.main.Tokenizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.Tokenizer</span></code></a>.</p>
</section>
<section id="id12">
<h3>Шаг 4.4. Получить векторы по индексам<a class="headerlink" href="#id12" title="Link to this heading"></a></h3>
<p>Реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors()</span></code></a>.</p>
<p>В случае если на вход приходит значение <code class="docutils literal notranslate"><span class="pre">None</span></code>, ожидается, что
метод вернёт все пары «индекс и вектор» соответствующего документа.
В противном случае возвращаются только те пары, индекс которых присутствует
в списке полученных на вход индексов.</p>
</section>
<section id="id13">
<h3>Шаг 4.5. Получить документы по индексам<a class="headerlink" href="#id13" title="Link to this heading"></a></h3>
<p>Реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents()</span></code></a>, который,
как и метод <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors()</span></code></a>,
принимает индексы.</p>
<p>В случае если на вход приходит значение <code class="docutils literal notranslate"><span class="pre">None</span></code>, метод возвращает все документы,
хранящиеся в базе данных.
В противном случае возвращаются только те документы, индексы которых присутствуют
в списке полученных на вход индексов.</p>
</section>
<section id="id14">
<h3>Шаг 5. Объявить сущность для поиска наиболее релевантного документа<a class="headerlink" href="#id14" title="Link to this heading"></a></h3>
<p>Теперь, когда векторная база данных создана, необходимо проверить её работу
на базовом алгоритме K-ближайших соседей. Для этого реализуйте класс
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.VectorDBSearchEngine" title="lab_4_retrieval_w_clustering.main.VectorDBSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.VectorDBSearchEngine</span></code></a>.
Его основная функция — ранжирование документов по степени схожести с запросом.</p>
<p>Данный класс наследуется от уже реализованного в предыдущей лабораторной работе
класса <a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.BasicSearchEngine" title="lab_3_ann_retriever.main.BasicSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.BasicSearchEngine</span></code></a>. В данном случае
наследование позволит использовать методы класса родителя, а также переопределить
некоторые из них.</p>
<p>В данном классе есть единственный внутренний атрибут <code class="docutils literal notranslate"><span class="pre">self._db</span></code>, который
хранит в себе объект класса <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB</span></code></a>.</p>
<p>Создание экземпляра данного класса может выглядеть следующим образом:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">stop_words</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;и&#39;</span><span class="p">,</span> <span class="s1">&#39;в&#39;</span><span class="p">,</span> <span class="s1">&#39;во&#39;</span><span class="p">,</span> <span class="s1">&#39;не&#39;</span><span class="p">]</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">DocumentVectorDB</span><span class="p">(</span><span class="n">stop_words</span><span class="p">)</span>
<span class="n">vector_search</span> <span class="o">=</span> <span class="n">VectorDBSearchEngine</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id15">
<h3>Шаг 5.1. Получить релевантные абзацы<a class="headerlink" href="#id15" title="Link to this heading"></a></h3>
<p>Теперь реализуйте поиск ближайших соседей по запросу с помощью метода
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.VectorDBSearchEngine.retrieve_relevant_documents" title="lab_4_retrieval_w_clustering.main.VectorDBSearchEngine.retrieve_relevant_documents"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.VectorDBSearchEngine.retrieve_relevant_documents()</span></code></a>.
На вход подаётся строка запроса и количество соседей,
которое мы хотим получить.</p>
<p>Благодаря тому, что была создана векторная база данных, не требуется дополнительно
токенизировать и векторизировать данные. Теперь Вы можете получить все необходимые данные
из объекта класса <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB</span></code></a>, который
хранится в соответствующем атрибуте.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>В данном методе необходимо использовать метод
<a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.BasicSearchEngine._calculate_knn" title="lab_3_ann_retriever.main.BasicSearchEngine._calculate_knn"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.BasicSearchEngine._calculate_knn()</span></code></a>
для нахождения наиболее релевантных <code class="docutils literal notranslate"><span class="pre">n</span></code> документов, а также
метод <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents()</span></code></a>
для получения релевантных документов по индексу.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Если на вход подаётся пустой аргумент, некорректное значение количества
релевантных документов или вызываемые методы возвращают значение <code class="docutils literal notranslate"><span class="pre">None</span></code>,
то необходимо поднять исключение <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
</div>
<p>Например, пусть метод получает на вход запрос <code class="docutils literal notranslate"><span class="pre">'Может,</span> <span class="pre">сходим</span> <span class="pre">за</span> <span class="pre">кофе?'</span></code> и количество релевантных
документов равное <code class="docutils literal notranslate"><span class="pre">2</span></code>.
Тогда ожидается, что метод вернёт следующий результат:
<code class="docutils literal notranslate"><span class="pre">[(0.9658317579543253,</span> <span class="pre">'Хорошо.</span> <span class="pre">Как</span> <span class="pre">твои</span> <span class="pre">дела?'),</span>
<span class="pre">(1.246293814290532,</span> <span class="pre">'Как</span> <span class="pre">ты</span> <span class="pre">смотришь</span> <span class="pre">на</span> <span class="pre">то,</span> <span class="pre">чтобы</span> <span class="pre">сходить</span> <span class="pre">попить</span> <span class="pre">кофе?')]</span></code></p>
</section>
<section id="start-py">
<h3>Шаг 6. Продемонстрировать результат в <code class="docutils literal notranslate"><span class="pre">start.py</span></code><a class="headerlink" href="#start-py" title="Link to this heading"></a></h3>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Выполнение Шагов 2-6 соответствует 6 баллам.</p>
</div>
<p>Продемонстрируйте результат работы токенизации по абзацам,
векторизации с помощью BM25, заполнения базы данных и ранжирования документов по
релевантности в функции <code class="docutils literal notranslate"><span class="pre">main()</span></code> модуля <code class="docutils literal notranslate"><span class="pre">start.py</span></code>.
Попробуйте в качестве запроса для поиска использовать
<code class="docutils literal notranslate"><span class="pre">&quot;Первый</span> <span class="pre">был</span> <span class="pre">не</span> <span class="pre">кто</span> <span class="pre">иной,</span> <span class="pre">как</span> <span class="pre">Михаил</span> <span class="pre">Александрович</span> <span class="pre">Берлиоз,</span> <span class="pre">председатель</span> <span class="pre">правления&quot;</span></code>,
и пусть значение <code class="docutils literal notranslate"><span class="pre">n_neighbours</span></code> будет равно 3.</p>
</section>
<section id="id16">
<h3>Шаг 7. Реализовать алгоритм кластеризации<a class="headerlink" href="#id16" title="Link to this heading"></a></h3>
<p>На предыдущих шагах Вы осуществили поиск релевантных абзацев по запросу
на основе алгоритма K-ближайших соседей (KNN). Однако при таком подходе
необходимо находить расстояние между вектором запроса и вектором каждого
абзаца из базы данных. В данной лабораторной работе таких абзацев всего
<code class="docutils literal notranslate"><span class="pre">1730</span></code>, тогда как в поисковых системах таких абзацев-документов
миллиарды. Именно поэтому полный перебор всех элементов - это дорого.
Чтобы сократить число таких переборов зачастую
используют различные алгоритмы, в частности алгоритм кластеризации.</p>
<p><strong>Алгоритм кластеризации</strong> позволяет группировать данные в наборы объектов,
называемых кластерами, тем самым сокращая пространство поиска. В один кластер попадают
объекты, которые имеют высокую степень сходства между собой, а различия между разными
группами будут значительными. Таким образом, вместо того чтобы сравнивать запрос с каждым
элементом базы данных, мы можем сначала определить, к какому кластеру относится запрос,
и затем выполнять поиск уже среди членов этого кластера. Это позволяет ускорить процесс
поиска в несколько раз.</p>
<p>Помимо скорости, кластеризация, при достаточно большой базе данных, может улучшить качество
поиска, так как она группирует похожие элементы вместе. Это делает результаты поиска более
релевантными, поскольку запросы будут сопоставляться с объектами, которые уже были отобраны
как наиболее подходящие среди всех документов.</p>
<p>За счёт сокращения векторного пространства поиска применение алгоритма кластеризации
также ведёт в снижению памяти, так как требуется хранить значительно меньшее количество
документов для сравнения и соответственно меньше дистанций.</p>
<p>В данной лабораторной работе Вам необходимо реализовать алгоритм кластеризации K-Means.
Теперь давайте более подробно познакомимся с данным алгоритмом кластеризации.</p>
<p><strong>Алгоритм K-Means</strong> — это базовый метод кластерного анализа, используемый для разбиения
множества точек данных на <code class="docutils literal notranslate"><span class="pre">k</span></code> кластеров, где <code class="docutils literal notranslate"><span class="pre">k</span></code> — фиксированное количество кластеров.
Каждый кластер характеризуется своим центром, называемым центроидом. Основная идея состоит
в том, чтобы минимизировать суммарную ошибку размещения точек относительно их центроидов.</p>
<p>Работу алгоритма кластеризации можно разделить на два основных этапа:</p>
<ol class="arabic simple">
<li><p><strong>Тренировка (Training)</strong> – создание модели кластеризации на основе обучающих данных.</p></li>
<li><p><strong>Инференс (Inference)</strong> – использование созданной модели для предсказания принадлежности
новых данных к определённым кластерам.</p></li>
</ol>
<p>Этап тренировки описывается следующими шагами:</p>
<ol class="arabic simple">
<li><p><strong>Инициализация центроидов</strong>. На данном шаге случайным образом выбираются <code class="docutils literal notranslate"><span class="pre">k</span></code>
векторов из базы данных. Данные векторы служат начальными центроидами для кластеров.</p></li>
<li><p><strong>Цикл обучения</strong>.
Сначала происходит присвоение точек кластеру. Для каждой точки данных
вычисляется расстояние до каждого центроида. Точка присваивается тому кластеру,
центроид которого находится ближе к ней.
Затем необходимо пересчитать центроиды, так как из-за добавления в кластер новых
векторов, центроид может сдвинуться. Обновление центроида происходит следующим образом:
считается среднее значение векторов, принадлежащих каждому кластеру.</p></li>
<li><p><strong>Проверка сходимости</strong>. Алгоритм проверяет, изменилось ли положение центроидов больше,
чем на определённый порог. Если значительных изменений в координатах центроидов не произошло,
значит, алгоритм достиг сходимости и процесс обучения можно заканчивать.</p></li>
</ol>
<p>После того как модель была обучена, её можно использовать для предсказания того, к какому кластеру
относятся новые наборы данных. Данный процесс называется инференсом. Модель использует
информацию о центрах кластеров, полученных на этапе тренировки, чтобы назначить каждому новому элементу
соответствующий кластер.</p>
<p>Визуализацию K-Means кластеризации Вы можете найти
<a class="reference external" href="https://www.naftaliharris.com/blog/visualizing-k-means-clustering/">тут</a></p>
</section>
<section id="id17">
<h3>Шаг 7.1. Объявить сущность для хранения кластеров<a class="headerlink" href="#id17" title="Link to this heading"></a></h3>
<p>Для того чтобы реализовать алгоритм кластеризации K-means, необходимо создать
сущность, которая будет хранить в себе ключевую информацию о кластере. Для этого
реализуйте класс <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO" title="lab_4_retrieval_w_clustering.main.ClusterDTO"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO</span></code></a>.</p>
<p>Класс имеет следующие атрибуты:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self.__centroid</span></code> - вектор центроида кластера (за вид вектора отвечает тип
<a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.Vector" title="lab_3_ann_retriever.main.Vector"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.Vector</span></code></a>);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self.__indices</span></code> - индексы документов, которые относятся к текущему кластеру.</p></li>
</ul>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Атрибуты <code class="docutils literal notranslate"><span class="pre">self.__centroid</span></code> и <code class="docutils literal notranslate"><span class="pre">self.__indices</span></code> являются приватными.
Подумайте, почему так сделано, и поделитесь ответом с ментором
во время защиты лабораторной работы.</p>
</div>
<p>Пример создания экземпляра класса:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.23</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.12</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
<span class="n">cluster</span> <span class="o">=</span> <span class="n">ClusterDTO</span><span class="p">(</span><span class="n">centroid</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id18">
<h3>Шаг 7.1.1. Получить количество документов в кластере<a class="headerlink" href="#id18" title="Link to this heading"></a></h3>
<p>Реализуйте магический метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.__len__" title="lab_4_retrieval_w_clustering.main.ClusterDTO.__len__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.__len__()</span></code></a>, который
позволяет получить количество документов в кластере.</p>
<p>Метод <code class="docutils literal notranslate"><span class="pre">__len__</span></code> называют магическим, потому что его переопределение меняет поведение объекта
в случае, когда необходимо получить его длину. Данный метод вызывается при использовании
встроенной функции <code class="docutils literal notranslate"><span class="pre">len()</span></code>, поэтому результат переопределения можно проверить, вызвав
<code class="docutils literal notranslate"><span class="pre">len</span></code> и передав экземпляр класса в качестве аргумента.</p>
</section>
<section id="id19">
<h3>Шаг 7.1.2. Получить центроид<a class="headerlink" href="#id19" title="Link to this heading"></a></h3>
<p>Реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid" title="lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid()</span></code></a>, который
позволяет получить доступ к приватному атрибуту, хранящему центроид кластера.</p>
</section>
<section id="id20">
<h3>Шаг 7.1.3. Изменить центроид<a class="headerlink" href="#id20" title="Link to this heading"></a></h3>
<p>После того как в алгоритме кластеризации центроиды будут обновлены, необходимо
сообщить об этом изменении кластеру, то есть сохранить эту информацию в объекте
текущего класса. Для того чтобы после обновления сохранить актуальную информацию
о центроиде, реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.set_new_centroid" title="lab_4_retrieval_w_clustering.main.ClusterDTO.set_new_centroid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.set_new_centroid()</span></code></a>,
который изменяет текущее состояние атрибута <code class="docutils literal notranslate"><span class="pre">self.__centroid</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Если на вход подаётся пустой аргумент,
то необходимо поднять исключение <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
</div>
</section>
<section id="id21">
<h3>Шаг 7.1.4. Очистить кластеры<a class="headerlink" href="#id21" title="Link to this heading"></a></h3>
<p>До тех пор, пока центроиды не достигли сходимости, необходимо их обновлять. Но
каждый раз после их обновления экземпляр текущего класса продолжает хранить
в себе информацию об индексах документов, хранящихся в кластере. Данное поведение
является некорректным, так как получив новые центроиды, кластеры должны формироваться
заново. Для того чтобы очистить кластер, реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.erase_indices" title="lab_4_retrieval_w_clustering.main.ClusterDTO.erase_indices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.erase_indices()</span></code></a>.</p>
</section>
<section id="id22">
<h3>Шаг 7.1.5. Добавить новый документ в кластер<a class="headerlink" href="#id22" title="Link to this heading"></a></h3>
<p>Кластеру необходимо иметь возможность добавлять в себя новый элемент.
Для того чтобы кластер мог осуществить данное действие, реализуйте
метод <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.add_document_index" title="lab_4_retrieval_w_clustering.main.ClusterDTO.add_document_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.add_document_index()</span></code></a>,
который пополняет соответствующий атрибут данного класса индексом нового документа.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Если на вход подаётся пустой аргумент или аргумент <code class="docutils literal notranslate"><span class="pre">index</span></code> принимает
отрицательное значение, то необходимо поднять исключение <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
</div>
</section>
<section id="id23">
<h3>Шаг 7.1.6. Получить индексы документов кластера<a class="headerlink" href="#id23" title="Link to this heading"></a></h3>
<p>Реализуйте метод <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.get_indices" title="lab_4_retrieval_w_clustering.main.ClusterDTO.get_indices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.get_indices()</span></code></a>,
который позволяет получить список всех индексов документов, которые хранятся
в текущем кластере. В дальнейшем такое поведение позволит получить документы кластера,
наиболее близкого к пользовательскому запросу, а следовательно, получить наиболее
релевантные документы.</p>
</section>
<section id="id24">
<h3>Шаг 7.2. Объявить сущность для алгоритма кластеризации<a class="headerlink" href="#id24" title="Link to this heading"></a></h3>
<p>Теперь Вам необходимо реализовать алгоритм кластеризации K-Means. Для
этого реализуйте класс <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.KMeans" title="lab_4_retrieval_w_clustering.main.KMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.KMeans</span></code></a>.</p>
<p>Класс имеет следующие атрибуты:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self.__clusters</span></code> - список, который хранит в себе объекты класса
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO" title="lab_4_retrieval_w_clustering.main.ClusterDTO"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO</span></code></a>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self._db</span></code> - объект класса <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB</span></code></a>,
который хранит в себе векторную базу данных;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self._n_clusters</span></code> - количество кластеров.</p></li>
</ul>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Атрибуты <code class="docutils literal notranslate"><span class="pre">self._db</span></code> и <code class="docutils literal notranslate"><span class="pre">self._n_clusters</span></code> являются защищёнными, а
атрибут <code class="docutils literal notranslate"><span class="pre">self.__clusters</span></code> - приватным. Подумайте,
почему так сделано, и поделитесь ответом с ментором во время защиты
лабораторной работы.</p>
</div>
<p>Пример создания экземпляра класса:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">stop_words</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;и&#39;</span><span class="p">,</span> <span class="s1">&#39;в&#39;</span><span class="p">,</span> <span class="s1">&#39;во&#39;</span><span class="p">,</span> <span class="s1">&#39;не&#39;</span><span class="p">]</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">DocumentVectorDB</span><span class="p">(</span><span class="n">stop_words</span><span class="p">)</span>
<span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id25">
<h3>Шаг 7.2.1. Запустить итерацию обучения алгоритма кластеризации<a class="headerlink" href="#id25" title="Link to this heading"></a></h3>
<p>Как уже рассматривалось выше, алгоритм необходимо обучать до тех пор,
пока центроиды кластера не сойдутся к заданному порогу. Для того чтобы
пройти одну полную итерацию обучения, реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.KMeans.run_single_train_iteration" title="lab_4_retrieval_w_clustering.main.KMeans.run_single_train_iteration"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.KMeans.run_single_train_iteration()</span></code></a>,
который возвращает список обновлённых объектов класса
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO" title="lab_4_retrieval_w_clustering.main.ClusterDTO"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO</span></code></a>.</p>
<p>В ходе реализации данного метода необходимо выполнить следующие шаги:</p>
<ol class="arabic simple">
<li><p>Очистить индексы документов в каждом кластере, так как, пока центроиды не сошлись,
необходимо заново заполнять кластеры индексами документов на основе новых центроидов.</p></li>
<li><p>Посчитать расстояние от каждого вектора документа из базы данных до центроида
каждого кластера.</p></li>
<li><p>Для каждого документа найти ближайший к нему центроид.</p></li>
<li><p>Заполнить текущий кластер новым индексом документа.</p></li>
<li><p>Обновить центроид каждого кластера, посчитав его вектор как среднее арифметическое
векторов документов текущего кластера.</p></li>
</ol>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>В данном методе необходимо использовать следующие методы:
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.erase_indices" title="lab_4_retrieval_w_clustering.main.ClusterDTO.erase_indices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.erase_indices()</span></code></a>,
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors()</span></code></a>,
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid" title="lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid()</span></code></a>,
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.add_document_index" title="lab_4_retrieval_w_clustering.main.ClusterDTO.add_document_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.add_document_index()</span></code></a>,
и <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.set_new_centroid" title="lab_4_retrieval_w_clustering.main.ClusterDTO.set_new_centroid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.set_new_centroid()</span></code></a>,
а также функцию
<a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.calculate_distance" title="lab_3_ann_retriever.main.calculate_distance"><code class="xref py py-func docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.calculate_distance()</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Если вызываемые методы возвращают значение <code class="docutils literal notranslate"><span class="pre">None</span></code>,
то необходимо поднять исключение <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
</div>
</section>
<section id="id26">
<h3>Шаг 7.2.2. Проверить сходимость центроидов<a class="headerlink" href="#id26" title="Link to this heading"></a></h3>
<p>Реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.KMeans._is_convergence_reached" title="lab_4_retrieval_w_clustering.main.KMeans._is_convergence_reached"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.KMeans._is_convergence_reached()</span></code></a>,
который проверяет, сошлись ли центроиды до обновления с центроидами после обновления.</p>
<p>Считается, что центроиды сошлись, если расстояние между ними меньше некоторого
порогового значения, которое подаётся на вход данному методу. В таком случае метод
возвращает значение <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>В данном методе необходимо вызвать функцию
<a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.calculate_distance" title="lab_3_ann_retriever.main.calculate_distance"><code class="xref py py-func docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.calculate_distance()</span></code></a>, а
также метод <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid" title="lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid()</span></code></a>,
чтобы получить центроиды до и после обновления.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Если на вход подаётся пустой аргумент или вызываемые методы возвращают
значение <code class="docutils literal notranslate"><span class="pre">None</span></code>, то необходимо поднять исключение <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
</div>
</section>
<section id="id27">
<h3>Шаг 7.2.3. Обучить алгоритм кластеризации<a class="headerlink" href="#id27" title="Link to this heading"></a></h3>
<p>Теперь у Вас есть всё, чтобы обучить алгоритм кластеризации K-Means.
Реализуйте метод <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.KMeans.train" title="lab_4_retrieval_w_clustering.main.KMeans.train"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.KMeans.train()</span></code></a>.</p>
<p>Рассмотрим реализацию данного метода по шагам:</p>
<ol class="arabic simple">
<li><p><strong>Инициализация центроидов</strong>. В данной лабораторной работе в качестве начальных
центроидов необходимо взять первые <code class="docutils literal notranslate"><span class="pre">n</span></code> векторов из построенной базы данных, которая
хранится в соответствующем атрибуте текущего класса. Затем Вам необходимо заполнить
атрибут <code class="docutils literal notranslate"><span class="pre">self.__clusters</span></code> объектами класса
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO" title="lab_4_retrieval_w_clustering.main.ClusterDTO"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO</span></code></a>.</p></li>
<li><p><strong>Цикл обучения</strong>.
За логику одной итерации обучения отвечает уже реализованный ранее метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.KMeans.run_single_train_iteration" title="lab_4_retrieval_w_clustering.main.KMeans.run_single_train_iteration"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.KMeans.run_single_train_iteration()</span></code></a>,
который возвращает новые кластера после обновления центроидов.</p></li>
<li><p><strong>Проверка сходимости</strong>. В случае если центроиды сошлись, необходимо закончить цикл обучения
и заключительный раз обновить кластера, чтобы поддерживать объекты класса
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO" title="lab_4_retrieval_w_clustering.main.ClusterDTO"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO</span></code></a> в актуальном состоянии. В
противном случае, происходит переход на новую итерацию обучения.</p></li>
</ol>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>В данном методе необходимо использовать следующие методы:
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors()</span></code></a>,
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.KMeans.run_single_train_iteration" title="lab_4_retrieval_w_clustering.main.KMeans.run_single_train_iteration"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.KMeans.run_single_train_iteration()</span></code></a>
и <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.KMeans._is_convergence_reached" title="lab_4_retrieval_w_clustering.main.KMeans._is_convergence_reached"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.KMeans._is_convergence_reached()</span></code></a>.</p>
</div>
</section>
<section id="id28">
<h3>Шаг 7.2.4. Сделать инференс модели кластеризации<a class="headerlink" href="#id28" title="Link to this heading"></a></h3>
<p>Теперь, когда Вы натренировали модель на то, чтобы определять кластер для документа,
реализуйте метод <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.KMeans.infer" title="lab_4_retrieval_w_clustering.main.KMeans.infer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.KMeans.infer()</span></code></a>, который
позволит получить ближайший кластер к запросу пользователя.</p>
<p>Для того чтобы реализовать данный метод, необходимо выполнить следующие шаги:</p>
<ol class="arabic simple">
<li><p>Найти расстояние между вектором запроса и центроидом каждого кластера. Кластер,
центроид которого имеет наименьшее расстояние до вектора запроса, выбирается для
дальнейшего поиска наиболее релевантных документов.</p></li>
<li><p>Получить индексы тех документов, которые содержатся в ближайшем к запросу
пользователя кластере.</p></li>
<li><p>Получить векторы документов из кластера по индексу.</p></li>
<li><p>Найти расстояние между вектором запроса и вектором каждого документа из ближайшего кластера.</p></li>
<li><p>Выбрать <code class="docutils literal notranslate"><span class="pre">n</span></code> ближайших документов кластера.</p></li>
</ol>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>В данном методе необходимо использовать функцию
<a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.calculate_distance" title="lab_3_ann_retriever.main.calculate_distance"><code class="xref py py-func docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.calculate_distance()</span></code></a>, а также
следующие методы:
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid" title="lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid()</span></code></a>,
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors()</span></code></a> и
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.get_indices" title="lab_4_retrieval_w_clustering.main.ClusterDTO.get_indices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.get_indices()</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Если на вход подаётся некорректное значение или вызываемые методы возвращают значение <code class="docutils literal notranslate"><span class="pre">None</span></code>,
то необходимо поднять исключение <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
</div>
<p>Например, пусть метод принимает на вход следующий вектор запроса
<code class="docutils literal notranslate"><span class="pre">(0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.9658317579543253,</span> <span class="pre">0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0)</span></code> и количество релевантных
документов равное <code class="docutils literal notranslate"><span class="pre">2</span></code>. Тогда метод вернёт следующий результат:
<code class="docutils literal notranslate"><span class="pre">[(0.9658317579543253,</span> <span class="pre">1),</span> <span class="pre">(1.246293814290532,</span> <span class="pre">3)]</span></code></p>
</section>
<section id="k-means">
<h3>Шаг 8. Объявить сущность для поиска релевантных документов с помощью алгоритма K-Means<a class="headerlink" href="#k-means" title="Link to this heading"></a></h3>
<p>На <strong>Шаге 5</strong> Вы уже создали алгоритм поиска <code class="docutils literal notranslate"><span class="pre">n</span></code> релевантных документов, основываясь на
алгоритме K-ближайших соседей. Теперь осуществим поиск релевантных документов на основе K-Means
алгоритма. Для этого реализуйте класс
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusteringSearchEngine" title="lab_4_retrieval_w_clustering.main.ClusteringSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusteringSearchEngine</span></code></a>.</p>
<p>Класс имеет следующие атрибуты:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self.__algo</span></code> - объект класса <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.KMeans" title="lab_4_retrieval_w_clustering.main.KMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.KMeans</span></code></a>;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self._db</span></code> - объект класса <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB</span></code></a>,
который хранит в себе векторную базу данных.</p></li>
</ul>
<p>При инициализации класса <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusteringSearchEngine" title="lab_4_retrieval_w_clustering.main.ClusteringSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusteringSearchEngine</span></code></a>
обратите внимание на то, что атрибут <code class="docutils literal notranslate"><span class="pre">self.__algo</span></code> хранит в себе лишь объект класса. Для того
чтобы использовать алгоритм K-Means дальше, необходимо его обучить.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Атрибут <code class="docutils literal notranslate"><span class="pre">self._db</span></code> является защищённым, а
атрибут <code class="docutils literal notranslate"><span class="pre">self.__algo</span></code> - приватным. Подумайте,
почему так сделано, и поделитесь ответом с ментором во время защиты
лабораторной работы.</p>
</div>
<p>Пример создания экземпляра класса:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">stop_words</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;и&#39;</span><span class="p">,</span> <span class="s1">&#39;в&#39;</span><span class="p">,</span> <span class="s1">&#39;во&#39;</span><span class="p">,</span> <span class="s1">&#39;не&#39;</span><span class="p">]</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">DocumentVectorDB</span><span class="p">(</span><span class="n">stop_words</span><span class="p">)</span>
<span class="n">clustering_search</span> <span class="o">=</span> <span class="n">ClusteringSearchEngine</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id29">
<h3>Шаг 8.1. Получить релевантные абзацы с помощью алгоритма K-Means<a class="headerlink" href="#id29" title="Link to this heading"></a></h3>
<p>Реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusteringSearchEngine.retrieve_relevant_documents" title="lab_4_retrieval_w_clustering.main.ClusteringSearchEngine.retrieve_relevant_documents"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusteringSearchEngine.retrieve_relevant_documents()</span></code></a>.
На вход подаётся строка запроса и количество релевантных данному запросу документов.</p>
<p>Вам необходимо сделать инференс модели кластеризации и получить индексы ближайших
к пользовательскому запросу документов. Однако обратите внимание на то, что
на выходе метод ожидает получить дистанции и сами документы в формате строки.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>В данном методе необходимо использовать метод
<a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.Tokenizer.tokenize" title="lab_3_ann_retriever.main.Tokenizer.tokenize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.Tokenizer.tokenize()</span></code></a>,
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.BM25Vectorizer.vectorize" title="lab_4_retrieval_w_clustering.main.BM25Vectorizer.vectorize"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.BM25Vectorizer.vectorize()</span></code></a>,
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents()</span></code></a>,
а также <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.KMeans.infer" title="lab_4_retrieval_w_clustering.main.KMeans.infer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.KMeans.infer()</span></code></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Если на вход подаётся некорректное значение или вызываемые методы возвращают значение <code class="docutils literal notranslate"><span class="pre">None</span></code>,
то необходимо поднять исключение <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
</div>
</section>
<section id="id30">
<h3>Шаг 9. Продемонстрировать результаты в <code class="docutils literal notranslate"><span class="pre">start.py</span></code><a class="headerlink" href="#id30" title="Link to this heading"></a></h3>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Выполнение Шагов 7-9 соответствует 8 баллам.</p>
</div>
<p>Продемонстрируйте результат ранжирования документов по релевантности
с помощью K-Means алгоритма в функции <code class="docutils literal notranslate"><span class="pre">main()</span></code> модуля <code class="docutils literal notranslate"><span class="pre">start.py</span></code>.
Попробуйте в качестве запроса для поиска использовать
<code class="docutils literal notranslate"><span class="pre">&quot;Первый</span> <span class="pre">был</span> <span class="pre">не</span> <span class="pre">кто</span> <span class="pre">иной,</span> <span class="pre">как</span> <span class="pre">Михаил</span> <span class="pre">Александрович</span> <span class="pre">Берлиоз,</span> <span class="pre">председатель</span> <span class="pre">правления&quot;</span></code>,
и пусть значение <code class="docutils literal notranslate"><span class="pre">n_neighbours</span></code> будет равно 5.</p>
</section>
<section id="id31">
<h3>Шаг 10. Проанализировать результат работы K-Means кластеризации<a class="headerlink" href="#id31" title="Link to this heading"></a></h3>
<p>На предыдущих шагах Вы построили алгоритм кластеризации K-Means,
который позволяет разбивать данные на группы (кластеры).</p>
<p>При создании экземпляров класса <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.KMeans" title="lab_4_retrieval_w_clustering.main.KMeans"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.KMeans</span></code></a>
и класса <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusteringSearchEngine" title="lab_4_retrieval_w_clustering.main.ClusteringSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusteringSearchEngine</span></code></a>
количество кластеров задавалось произвольно.
Однако существуют различные способы подбора наиболее подходящего количества
кластеров. Один из таких способов называется <strong>метод локтя (elbow method)</strong>.</p>
<p><strong>Метод локтя</strong> – это подход для определения оптимального
числа кластеров при использовании алгоритмов кластерного анализа K-Means.
Этот метод основан на анализе суммы квадратов ошибок (SSE),
которая представляет собой сумму квадратов расстояний между объектами кластера и центроидом
соответствующего кластера. Метод локтя помогает выбрать количество кластеров
таким образом, чтобы минимизировать <code class="docutils literal notranslate"><span class="pre">SSE</span></code>, но при этом избежать чрезмерной фрагментации
данных.</p>
<p>Метрика <code class="docutils literal notranslate"><span class="pre">SSE</span></code> считается по следующей формуле:</p>
<p><span class="math notranslate nohighlight">\(\sum^{j=1}_{k}\sum^{i=1}_{n}\sum^{p=1}_{l}({c_j}^p - {v_{i,j}}^p)^2\)</span>, где</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> — размерность вектора;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n</span></code> — количество объектов в кластере;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">k</span></code> — число кластеров;</p></li>
<li><p><span class="math notranslate nohighlight">\({c_j}^p\)</span> — p-ый элемент вектора центроида j-того кластера;</p></li>
<li><p><span class="math notranslate nohighlight">\({v_{i,j}}^p\)</span> - p-ый элемент i-ого вектора объекта в j-том кластере.</p></li>
</ul>
<p>Метрику <code class="docutils literal notranslate"><span class="pre">SSE</span></code> принято считать для разного количества кластеров и по полученным значениям
строить график. На графике ищется точка «излома», где дальнейшее увеличение числа кластеров
приводит к незначительному уменьшению суммы квадратов расстояний.</p>
<p>Пример такого графика представлен на следующем изображении:</p>
<figure class="align-default">
<img alt="../../../../_images/elbow_method.png" src="../../../../_images/elbow_method.png" />
</figure>
<p>Глядя на график, можно догадаться, почему подход называется «метод локтя».
Оптимальное значение количества кластеров соответствует
точке «изгиба локтя».</p>
</section>
<section id="sse">
<h3>Шаг 10.1. Посчитать метрику SSE<a class="headerlink" href="#sse" title="Link to this heading"></a></h3>
<p>Реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.KMeans.calculate_square_sum" title="lab_4_retrieval_w_clustering.main.KMeans.calculate_square_sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.KMeans.calculate_square_sum()</span></code></a>.</p>
<p>Рассмотрим реализацию данного метода по шагам:</p>
<ol class="arabic simple">
<li><p>Получить для каждого кластера из атрибута <code class="docutils literal notranslate"><span class="pre">self.__clusters</span></code> центроид
и документы, хранящиеся в данном кластере.</p></li>
<li><p>Посчитать сумму квадратов разности координат для каждой пары центроид
кластера и документ кластера.</p></li>
<li><p>Посчитать сумму полученных на предыдущем шаге значений внутри одного кластера.</p></li>
<li><p>Посчитать сумму полученных значений на <strong>Шаге 3</strong> для всех кластеров.</p></li>
</ol>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>В данном методе необходимо использовать метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid" title="lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid()</span></code></a>,
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors()</span></code></a> и
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.get_indices" title="lab_4_retrieval_w_clustering.main.ClusterDTO.get_indices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.get_indices()</span></code></a>.</p>
</div>
</section>
<section id="id32">
<h3>Шаг 10.2. Получить метрику SSE в поисковой системе<a class="headerlink" href="#id32" title="Link to this heading"></a></h3>
<p>Реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusteringSearchEngine.calculate_square_sum" title="lab_4_retrieval_w_clustering.main.ClusteringSearchEngine.calculate_square_sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusteringSearchEngine.calculate_square_sum()</span></code></a>,
который возвращает сумму квадратов расстояний от векторов кластера до центроида.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>В данном методе необходимо использовать метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.KMeans.calculate_square_sum" title="lab_4_retrieval_w_clustering.main.KMeans.calculate_square_sum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.KMeans.calculate_square_sum()</span></code></a>.</p>
</div>
</section>
<section id="id33">
<h3>Шаг 11. Создать отчёт с информацией о кластерах<a class="headerlink" href="#id33" title="Link to this heading"></a></h3>
<section id="id34">
<h4>Шаг 11.1. Получить информацию о кластерах<a class="headerlink" href="#id34" title="Link to this heading"></a></h4>
<p>Реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.KMeans.get_clusters_info" title="lab_4_retrieval_w_clustering.main.KMeans.get_clusters_info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.KMeans.get_clusters_info()</span></code></a>.</p>
<p>Данный метод позволяет получить некоторую информацию о полученных кластерах, а
именно идентификатор кластера и несколько самых ближайших к центроиду документов
из текущего кластера. Количество ближайших документов задаётся входящим аргументом.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>В данном методе необходимо использовать функцию
<a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.calculate_distance" title="lab_3_ann_retriever.main.calculate_distance"><code class="xref py py-func docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.calculate_distance()</span></code></a>, а также методы
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid" title="lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.get_centroid()</span></code></a>,
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectors()</span></code></a>,
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusterDTO.get_indices" title="lab_4_retrieval_w_clustering.main.ClusterDTO.get_indices"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusterDTO.get_indices()</span></code></a> и
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents()</span></code></a>.</p>
</div>
<p>Пример структурированной информации о кластерах сохранён в файле
<code class="docutils literal notranslate"><span class="pre">&quot;./assets/states/report_example.json&quot;</span></code>,
индекс кластера и документы, которые образуют данный кластер,
можно найти по соответствующим ключам <code class="docutils literal notranslate"><span class="pre">&quot;cluster_id&quot;</span></code>
и <code class="docutils literal notranslate"><span class="pre">&quot;documents&quot;</span></code>.</p>
</section>
<section id="json">
<h4>Шаг 11.2. Сохранить отчёт в формате json<a class="headerlink" href="#json" title="Link to this heading"></a></h4>
<p>Реализуйте метод <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusteringSearchEngine.make_report" title="lab_4_retrieval_w_clustering.main.ClusteringSearchEngine.make_report"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusteringSearchEngine.make_report()</span></code></a>,
который сохраняет полученную в методе
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.KMeans.get_clusters_info" title="lab_4_retrieval_w_clustering.main.KMeans.get_clusters_info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.KMeans.get_clusters_info()</span></code></a> информацию о кластерах в
файл <code class="docutils literal notranslate"><span class="pre">assets/report.json</span></code>.</p>
</section>
</section>
<section id="id35">
<h3>Шаг 12. Продемонстрировать результаты в <code class="docutils literal notranslate"><span class="pre">start.py</span></code><a class="headerlink" href="#id35" title="Link to this heading"></a></h3>
<p>Продемонстрируйте результат отчёта по кластеризации в функции
<code class="docutils literal notranslate"><span class="pre">main()</span></code> модуля <code class="docutils literal notranslate"><span class="pre">start.py</span></code>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Проведите анализ полученной информации. Ответьте на вопрос:
«Что объединяет те документы, которые попали в один кластер?»
Поделитесь ответом с ментором во время защиты данной лабораторной
работы.</p>
</div>
<p>Продемонстрируйте в функции <code class="docutils literal notranslate"><span class="pre">main()</span></code> модуля <code class="docutils literal notranslate"><span class="pre">start.py</span></code>
работу метода локтя для каждого кластера в диапазоне <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">15)</span></code>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Проведите анализ того, какое количество кластеров является
наиболее оптимальным.</p>
</div>
</section>
<section id="api">
<h3>Шаг 13. Предоставить унифицированный API для всех поисковых систем<a class="headerlink" href="#api" title="Link to this heading"></a></h3>
<p>Теперь, когда все алгоритмы проанализированы и реализованы, Вы можете
создать единый API для работы с ними. Унификация интерфейса позволит
упростить работу пользователя с имеющимися сущностями.</p>
<p>На данный момент у Вас реализованы следующие оптимизированные алгоритмы векторного
поиска: <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.VectorDBSearchEngine" title="lab_4_retrieval_w_clustering.main.VectorDBSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.VectorDBSearchEngine</span></code></a>,
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusteringSearchEngine" title="lab_4_retrieval_w_clustering.main.ClusteringSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusteringSearchEngine</span></code></a>, а также
<a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.BasicSearchEngine" title="lab_3_ann_retriever.main.BasicSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.BasicSearchEngine</span></code></a> и
<a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.AdvancedSearchEngine" title="lab_3_ann_retriever.main.AdvancedSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.AdvancedSearchEngine</span></code></a>. Однако два последних
не умеют работать с векторной базой данных. Необходимо добавить им такое поведение.</p>
<p>Для этого реализуйте класс
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.VectorDBEngine" title="lab_4_retrieval_w_clustering.main.VectorDBEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.VectorDBEngine</span></code></a>, который предоставляет
унифицированный интерфейс для алгоритма <a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.BasicSearchEngine" title="lab_3_ann_retriever.main.BasicSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.BasicSearchEngine</span></code></a>
и алгоритма <a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.AdvancedSearchEngine" title="lab_3_ann_retriever.main.AdvancedSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.AdvancedSearchEngine</span></code></a> и добавляет
возможность работать данным классам с базой документов и векторов.</p>
<p>Класс имеет следующие атрибуты:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">self._db</span></code> - объект класса <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB</span></code></a>,
который хранит в себе векторную базу данных;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">self._engine</span></code> - объект класса <a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.BasicSearchEngine" title="lab_3_ann_retriever.main.BasicSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.BasicSearchEngine</span></code></a>.</p></li>
</ul>
</section>
<section id="id36">
<h3>Шаг 13.1. Предоставить унифицированный API для получения релевантных документов<a class="headerlink" href="#id36" title="Link to this heading"></a></h3>
<p>Реализуйте метод
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.VectorDBEngine.retrieve_relevant_documents" title="lab_4_retrieval_w_clustering.main.VectorDBEngine.retrieve_relevant_documents"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.VectorDBEngine.retrieve_relevant_documents()</span></code></a>,
который позволяет получить <code class="docutils literal notranslate"><span class="pre">n</span></code> наиболее релевантных документов по пользовательскому
запросу с помощью каждого алгоритма.</p>
</section>
<section id="id37">
<h3>Шаг 13.2. Предоставить унифицированный API для простого К-мерного дерева<a class="headerlink" href="#id37" title="Link to this heading"></a></h3>
<p>Реализуйте класс <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.VectorDBTreeSearchEngine" title="lab_4_retrieval_w_clustering.main.VectorDBTreeSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.VectorDBTreeSearchEngine</span></code></a>,
который наследуется от созданного ранее класса
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.VectorDBEngine" title="lab_4_retrieval_w_clustering.main.VectorDBEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.VectorDBEngine</span></code></a>.</p>
<p>При инициализации данного класса необходимо создать объект класса
<a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.SearchEngine" title="lab_3_ann_retriever.main.SearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.SearchEngine</span></code></a> и проиндексировать
все документы, используя векторную базу данных.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>При инициализации необходимо вызвать методы:
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectorizer" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectorizer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectorizer()</span></code></a>,
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_tokenizer" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_tokenizer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_tokenizer()</span></code></a>,
<a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.SearchEngine.index_documents" title="lab_3_ann_retriever.main.SearchEngine.index_documents"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.SearchEngine.index_documents()</span></code></a> и
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents()</span></code></a>.</p>
</div>
<p>Пример создания экземпляра класса:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">stop_words</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;и&#39;</span><span class="p">,</span> <span class="s1">&#39;в&#39;</span><span class="p">,</span> <span class="s1">&#39;во&#39;</span><span class="p">,</span> <span class="s1">&#39;не&#39;</span><span class="p">]</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">DocumentVectorDB</span><span class="p">(</span><span class="n">stop_words</span><span class="p">)</span>
<span class="n">vector_search</span> <span class="o">=</span> <span class="n">VectorDBTreeSearchEngine</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id38">
<h3>Шаг 13.3. Предоставить унифицированный API для оптимизированного К-мерного дерева<a class="headerlink" href="#id38" title="Link to this heading"></a></h3>
<p>Реализуйте класс <a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.VectorDBAdvancedSearchEngine" title="lab_4_retrieval_w_clustering.main.VectorDBAdvancedSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.VectorDBAdvancedSearchEngine</span></code></a>,
который также наследуется от созданного ранее класса
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.VectorDBEngine" title="lab_4_retrieval_w_clustering.main.VectorDBEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.VectorDBEngine</span></code></a> и перенимает все его атрибуты
и поведение.</p>
<p>При инициализации данного класса необходимо создать объект класса
<a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.AdvancedSearchEngine" title="lab_3_ann_retriever.main.AdvancedSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.AdvancedSearchEngine</span></code></a> и проиндексировать
все документы, используя векторную базу данных.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>При инициализации необходимо вызвать методы:
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectorizer" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectorizer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_vectorizer()</span></code></a>,
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_tokenizer" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_tokenizer"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_tokenizer()</span></code></a>,
<a class="reference internal" href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html#lab_3_ann_retriever.main.SearchEngine.index_documents" title="lab_3_ann_retriever.main.SearchEngine.index_documents"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_3_ann_retriever.main.SearchEngine.index_documents()</span></code></a> и
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents" title="lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.DocumentVectorDB.get_raw_documents()</span></code></a>.</p>
</div>
<p>Пример создания экземпляра класса:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="n">stop_words</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;и&#39;</span><span class="p">,</span> <span class="s1">&#39;в&#39;</span><span class="p">,</span> <span class="s1">&#39;во&#39;</span><span class="p">,</span> <span class="s1">&#39;не&#39;</span><span class="p">]</span>
<span class="n">db</span> <span class="o">=</span> <span class="n">DocumentVectorDB</span><span class="p">(</span><span class="n">stop_words</span><span class="p">)</span>
<span class="n">vector_search</span> <span class="o">=</span> <span class="n">VectorDBAdvancedSearchEngine</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id39">
<h3>Шаг 14. Продемонстрировать результаты в <code class="docutils literal notranslate"><span class="pre">start.py</span></code><a class="headerlink" href="#id39" title="Link to this heading"></a></h3>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Выполнение Шагов 10-14 соответствует 10 баллам.</p>
</div>
<p>Продемонстрируйте полиморфное поведение классов
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.VectorDBSearchEngine" title="lab_4_retrieval_w_clustering.main.VectorDBSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.VectorDBSearchEngine</span></code></a>,
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.ClusteringSearchEngine" title="lab_4_retrieval_w_clustering.main.ClusteringSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.ClusteringSearchEngine</span></code></a>,
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.VectorDBTreeSearchEngine" title="lab_4_retrieval_w_clustering.main.VectorDBTreeSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.VectorDBTreeSearchEngine</span></code></a> и
<a class="reference internal" href="lab_4_retrieval_w_clustering.api.html#lab_4_retrieval_w_clustering.main.VectorDBAdvancedSearchEngine" title="lab_4_retrieval_w_clustering.main.VectorDBAdvancedSearchEngine"><code class="xref py py-class docutils literal notranslate"><span class="pre">lab_4_retrieval_w_clustering.main.VectorDBAdvancedSearchEngine</span></code></a>
в функции <code class="docutils literal notranslate"><span class="pre">main()</span></code> модуля <code class="docutils literal notranslate"><span class="pre">start.py</span></code> и получите <code class="docutils literal notranslate"><span class="pre">5</span></code> наиболее релевантных
документов на пользовательский запрос
<code class="docutils literal notranslate"><span class="pre">'Первый</span> <span class="pre">был</span> <span class="pre">не</span> <span class="pre">кто</span> <span class="pre">иной,</span> <span class="pre">как</span> <span class="pre">Михаил</span> <span class="pre">Александрович</span> <span class="pre">Берлиоз,</span> <span class="pre">председатель</span> <span class="pre">правления'</span></code>.</p>
</section>
</section>
<section id="id40">
<h2>Полезные ссылки<a class="headerlink" href="#id40" title="Link to this heading"></a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://ru.wikipedia.org/wiki/Okapi_BM25">BM25</a></p></li>
<li><p><a class="reference external" href="https://www.datastax.com/guides/what-is-vector-search">Векторный поиск</a></p></li>
<li><p><a class="reference external" href="https://www.ibm.com/topics/k-means-clustering">K-Means кластеризация</a></p></li>
<li><p><a class="reference external" href="https://www.naftaliharris.com/blog/visualizing-k-means-clustering/">Визуализация K-Means</a></p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../lab_3_ann_retriever/lab_3_ann_retriever.api.html" class="btn btn-neutral float-left" title="lab_3_ann_retriever package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lab_4_retrieval_w_clustering.api.html" class="btn btn-neutral float-right" title="lab_4_retrieval_w_clustering package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Демидовский А.В. и другие.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>